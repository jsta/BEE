#!/usr/bin/env python3

"""BEEStart.

This script manages the startup of the BEE daemons and supporting services.
If no arguments are given this script will start the BEEWorkflowManager,
BEETaskManager, and all required supporting services. If any combination of
services is specified using the appropriate flag(s) then ONLY those services
will be started.
"""

import argparse
import getpass
import logging
import os
import shutil
import subprocess
import sys
import tempfile
from beeflow.common.config.config_driver import BeeConfig


def StartGDB(bc, debug=False):
    log = logging.getLogger(__name__)
    if shutil.which("ch-tar2dir") == None or shutil.which("ch-run") == None:
        log.error("ch-tar2dir or ch-run not found. Charliecloud required for neo4j container.")
        return False

    # Setup subprocess output
    stdout = subprocess.PIPE
    stderr = subprocess.STDOUT
    if debug:
        stdout = sys.stdout
        stderr = sys.stderr

    user_workdir = bc.userconfig.get('DEFAULT', 'bee_workdir')

    if bc.userconfig.has_section('graphdb'):
        graphsec = bc.userconfig['graphdb']
        db_hostname = graphsec.get('hostname','localhost')
        db_password = graphsec.get('dbpass','password')
        bolt_port = graphsec.get('bolt_port','7687')
        http_port = graphsec.get('http_port','7474')
        https_port = graphsec.get('https_port','7473')
        gdb_img = graphsec.get('gdb_image','')
        gdb_img_mntdir = graphsec.get('gdb_image_mntdir','/tmp')
    else:
        log.warning("[graphdb] section not found in configuration file, default values will be added")

        graphdb_dict = {
            'name': 'graphdb',
            'hostname': 'localhost',
            'dbpass': 'password',
            'bolt_port': 7687,
            'http_port': 7474,
            'https_port': 7473,
            'gdb_image': '/path/to/neo4j-ch.tar',
            'gdb_image_mntdir': '/tmp',
        }
        
        bc.add_section('user', graphdb_dict)
        log.warning("Please check " + str(bc.userconfig_file) + " and rerun startup")
        return False

    container_dir = tempfile.mkdtemp(suffix="_" + getpass.getuser(), prefix="gdb_", dir=str(gdb_img_mntdir))
    if debug:
        log.info("GraphDB container mount directory " + container_dir + " created")

    try:
        cp = subprocess.run(["ch-tar2dir",str(gdb_img),str(container_dir)], stdout=stdout, stderr=stderr, check=True)
    except subprocess.CalledProcessError as cp:
        log.error("ch-tar2dir failed")
        shutil.rmtree(container_dir)
        if debug:
            log.error(cp.stdout.decode())
            log.error("GraphDB container mount directory " + container_dir + " removed")
        return False

    newdir = os.path.split(container_dir)[1]

    container_path = container_dir + "/" + os.listdir(str(container_dir))[0]
    # Make the certificates directory
    container_certs_path = os.path.join(container_path, 'var/lib/neo4j/certificates')
    os.makedirs(container_certs_path, exist_ok=True)
    if debug:
        log.info('Created certificates directory %s', container_certs_path)
    # Setup working path data
    gdb_workdir = os.path.join(user_workdir, newdir)
    gdb_config_path = os.path.join(gdb_workdir, "conf")
    os.makedirs(gdb_config_path, exist_ok=True)
    gdb_configfile = shutil.copyfile(container_path + "/var/lib/neo4j/conf/neo4j.conf", gdb_config_path + "/neo4j.conf")
    if debug:
        log.info(gdb_configfile)
            
    cfile = open(gdb_configfile, "rt")
    data = cfile.read()
    cfile.close()
    data = data.replace("#dbms.connector.bolt.listen_address=:7687", "dbms.connector.bolt.listen_address=:" + str(bolt_port))
    data = data.replace("#dbms.connector.http.listen_address=:7474", "dbms.connector.http.listen_address=:" + str(http_port))
    data = data.replace("#dbms.connector.https.listen_address=:7473", "dbms.connector.https.listen_address=:" + str(https_port))
    cfile = open(gdb_configfile, "wt")
    cfile.write(data)
    cfile.close()

    gdb_data_path = os.path.join(gdb_workdir, "data")
    os.makedirs(gdb_data_path, exist_ok=True)

    gdb_log_path = os.path.join(gdb_workdir, "logs")
    os.makedirs(gdb_log_path, exist_ok=True)

    gdb_run_path = os.path.join(gdb_workdir, "run")
    os.makedirs(gdb_run_path, exist_ok=True)

    gdb_certs_path = os.path.join(gdb_workdir, "certificates")
    os.makedirs(gdb_certs_path, exist_ok=True)

    try:
        cp = subprocess.run([
            "ch-run","--set-env=" + container_path + "/environment","-b",
            gdb_config_path + ":/var/lib/neo4j/conf","-b",
            gdb_data_path + ":/data",
            "-b",
            gdb_log_path + ":/logs",
            "-b",
            gdb_run_path + ":/var/lib/neo4j/run",
            container_path,
            "--",
            "neo4j-admin",
            "set-initial-password",
            str(db_password)
        ], stdout=stdout, stderr=stderr, check=True)
    except subprocess.CalledProcessError as cp:
        log.error("neo4j-admin set-initial-password failed")
        log.error(cp.stdout.decode())
        return False

    try:
        cp = subprocess.run([
            "ch-run",
            "--set-env=" + container_path + "/environment",
            "-b",
            gdb_config_path + ":/var/lib/neo4j/conf",
            "-b",
            gdb_data_path + ":/data",
            "-b",
            gdb_log_path + ":/logs",
            "-b",
            gdb_run_path + ":/var/lib/neo4j/run",
            "-b",
            gdb_certs_path + ":/var/lib/neo4j/certificates",
            container_path,
            "--",
            "neo4j",
            "start"
        ], stdout=stdout, stderr=stderr, check=True)
    except subprocess.CalledProcessError as cp:
        if not debug:
            log.error(cp.stdout.decode())
        log.error("neo4j failed to start")
        return False

    return True

def StartWorkflowManager(debug=False):
    """Start BEEWorkflowManager. Return True if successful, False otherwise."""
    log = logging.getLogger(__name__)
    stdout = subprocess.PIPE
    stderr = subprocess.STDOUT
    if debug:
        stdout = sys.stdout
        stderr = sys.stdin
    try:
        cp = subprocess.run(["python", "beeflow/server/server.py"],
                            stdout=stdout, stderr=stderr, check=True)
    except subprocess.CalledProcessError as cp:
        log.error("BEEWorkflowManager failed")
        log.error(cp.stdout.decode())
        return False
    else:
        if debug:
            log.info(cp.stdout.decode())

    return True

def StartTaskManager(debug=False):
    """Start BEETaskManager. Return True if successful, False otherwise."""
    log = logging.getLogger(__name__)
    stdout = subprocess.PIPE
    stderr = subprocess.STDOUT
    if debug:
        stdout = sys.stdout
        stderr = sys.stdin
    try:
        cp = subprocess.run(["python", "beeflow/task_manager/task_manager.py"],
                            stdout=stdout, stderr=stderr, check=True)
    except subprocess.CalledProcessError as cp:
        log.error("BEETaskManager failed")
        log.error(cp.stdout.decode())
        return False
    else:
        if debug:
            log.info(cp.stdout.decode())

    return True

def parse_args(args=sys.argv[1:]):
    """Parse arguments."""
    parser = argparse.ArgumentParser(description=sys.modules[__name__].__doc__,
                                     formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument("-d", "--debug", action="store_true",
                        help="enable debugging output\nIf debug is specified all output will go to the console.\nOnly one BEE service may be launched by BEEStart if debug is requested.")
    parser.add_argument("--wfm", action="store_true", help="start the BEEWorkflowManager (implies --gdb)")
    parser.add_argument("--gdb", action="store_true", help="start the configured graph database")
    parser.add_argument("--tm", action="store_true", help="start the BEETaskManager")

    return parser.parse_args(args)

def start_process(init_fn, pid_file, **kwargs):
    """Start a new process with func as the entry point"""
    # TODO: Save pids in a pid file
    pid = os.fork()
    if pid == 0:
        status = 0 if init_fn(**kwargs) else 1
        sys.exit(status)
    # Create the PID file
    os.makedirs(os.path.expanduser('~/.beeflow'), exist_ok=True)
    with open(os.path.expanduser(f'~/.beeflow/{pid_file}'), 'w') as fp:
        fp.write(str(pid))
    return pid

def main():
    args = parse_args()
    start_all = not any([args.wfm, args.tm, args.gdb])
    if args.debug and not (sum([args.wfm,args.tm,args.gdb]) == 1):
        print("DEBUG requested, exactly one service must be specified",
              file=sys.stderr)
        return 1
    bc = BeeConfig()
    # Setup logging based on args.debug
    if args.debug:
        # Output everything to the console
        logging.basicConfig(level=logging.DEBUG)
    else:
        # TODO: Add defaults to the config
        try:
            bee_workdir = bc.userconfig['DEFAULT']['bee_workdir']
            logdir = bc.userconfig['DEFAULT']['logdir']
            logfile = bc.userconfig['DEFAULT']['logfile']
        except KeyError as e:
            print('Missing logdir or logfile section in user config',
                  file=sys.stderr)
            return 1
        path = os.path.join(bee_workdir, logdir) if logdir else bee_workdir
        path = os.path.join(path, logfile)
        logging.basicConfig(filename=path)
    log = logging.getLogger(__name__)

    # Start each process
    pids = []
    if args.wfm or start_all:
        pids.append(('Workflow Manager',
                     start_process(StartWorkflowManager, 'wfm.pid', debug=args.debug)))
    if args.tm or start_all:
        pids.append(('Task Manager', start_process(StartTaskManager, 'tm.pid', debug=args.debug)))
    if args.gdb or args.wfm or start_all:
        pids.append(('Graph Database', start_process(StartGDB, 'gdb.pid', bc=bc, debug=args.debug)))

    # Wait for everything to finish, if debug, otherwise just exit now
    if args.debug:
        try:
            while len(pids) > 0:
                pid, status = os.wait()
                # Get the index of the stored PID and then grab the name
                i = [p[1] for p in pids].index(pid)
                name = pids[i][0]
                if status == 0:
                    log.info('Started %s', name)
                else:
                    log.error('Error starting %s', name)
        except ChildProcessError as e:
            log.error('No child process to wait for')
    # TODO: Clean up the PID files
    return 0

if __name__ == "__main__":
    sys.exit(main())
