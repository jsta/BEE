#!/usr/bin/env python3

"""BEEStart.

This script manages the startup of the BEE daemons and supporting services.
If no arguments are given this script will start the BEEWorkflowManager,
BEETaskManager, and all required supporting services. If any combination of
services is specified using the appropriate flag(s) then ONLY those services
will be started.
"""

import argparse
import getpass
import logging
import os
import shutil
import subprocess
import sys
import tempfile
from beeflow.common.config.config_driver import BeeConfig


def StartGDB(bc, debug=False):
    """Start the graph database. Returns a Popen process object."""
    log = logging.getLogger(__name__)
    if shutil.which("ch-tar2dir") == None or shutil.which("ch-run") == None:
        log.error("ch-tar2dir or ch-run not found. Charliecloud required for neo4j container.")
        return None

    # Setup subprocess output
    stdout = subprocess.PIPE
    stderr = subprocess.STDOUT
    if debug:
        stdout = sys.stdout
        stderr = sys.stderr

    user_workdir = bc.userconfig.get('DEFAULT', 'bee_workdir')

    if bc.userconfig.has_section('graphdb'):
        graphsec = bc.userconfig['graphdb']
        db_hostname = graphsec.get('hostname','localhost')
        db_password = graphsec.get('dbpass','password')
        bolt_port = graphsec.get('bolt_port','7687')
        http_port = graphsec.get('http_port','7474')
        https_port = graphsec.get('https_port','7473')
        gdb_img = graphsec.get('gdb_image','')
        gdb_img_mntdir = graphsec.get('gdb_image_mntdir','/tmp')
    else:
        log.warning("[graphdb] section not found in configuration file, default values will be added")

        graphdb_dict = {
            'name': 'graphdb',
            'hostname': 'localhost',
            'dbpass': 'password',
            'bolt_port': 7687,
            'http_port': 7474,
            'https_port': 7473,
            'gdb_image': '/path/to/neo4j-ch.tar',
            'gdb_image_mntdir': '/tmp',
        }
        
        bc.add_section('user', graphdb_dict)
        log.warning("Please check " + str(bc.userconfig_file) + " and rerun startup")
        return None

    container_dir = tempfile.mkdtemp(suffix="_" + getpass.getuser(), prefix="gdb_", dir=str(gdb_img_mntdir))
    if debug:
        log.info("GraphDB container mount directory " + container_dir + " created")

    try:
        cp = subprocess.run(["ch-tar2dir",str(gdb_img),str(container_dir)], stdout=stdout, stderr=stderr, check=True)
    except subprocess.CalledProcessError as cp:
        log.error("ch-tar2dir failed")
        shutil.rmtree(container_dir)
        if debug:
            log.error("GraphDB container mount directory " + container_dir + " removed")
        return None

    newdir = os.path.split(container_dir)[1]

    container_path = container_dir + "/" + os.listdir(str(container_dir))[0]
    # Make the certificates directory
    container_certs_path = os.path.join(container_path, 'var/lib/neo4j/certificates')
    os.makedirs(container_certs_path, exist_ok=True)
    if debug:
        log.info('Created certificates directory %s', container_certs_path)
    # Setup working path data
    gdb_workdir = os.path.join(user_workdir, newdir)
    gdb_config_path = os.path.join(gdb_workdir, "conf")
    os.makedirs(gdb_config_path, exist_ok=True)
    gdb_configfile = shutil.copyfile(container_path + "/var/lib/neo4j/conf/neo4j.conf", gdb_config_path + "/neo4j.conf")
    if debug:
        log.info(gdb_configfile)
            
    cfile = open(gdb_configfile, "rt")
    data = cfile.read()
    cfile.close()
    data = data.replace("#dbms.connector.bolt.listen_address=:7687", "dbms.connector.bolt.listen_address=:" + str(bolt_port))
    data = data.replace("#dbms.connector.http.listen_address=:7474", "dbms.connector.http.listen_address=:" + str(http_port))
    data = data.replace("#dbms.connector.https.listen_address=:7473", "dbms.connector.https.listen_address=:" + str(https_port))
    cfile = open(gdb_configfile, "wt")
    cfile.write(data)
    cfile.close()

    gdb_data_path = os.path.join(gdb_workdir, "data")
    os.makedirs(gdb_data_path, exist_ok=True)

    gdb_log_path = os.path.join(gdb_workdir, "logs")
    os.makedirs(gdb_log_path, exist_ok=True)

    gdb_run_path = os.path.join(gdb_workdir, "run")
    os.makedirs(gdb_run_path, exist_ok=True)

    gdb_certs_path = os.path.join(gdb_workdir, "certificates")
    os.makedirs(gdb_certs_path, exist_ok=True)

    try:
        cp = subprocess.run([
            "ch-run","--set-env=" + container_path + "/environment","-b",
            gdb_config_path + ":/var/lib/neo4j/conf","-b",
            gdb_data_path + ":/data",
            "-b",
            gdb_log_path + ":/logs",
            "-b",
            gdb_run_path + ":/var/lib/neo4j/run",
            container_path,
            "--",
            "neo4j-admin",
            "set-initial-password",
            str(db_password)
        ], stdout=stdout, stderr=stderr, check=True)
    except subprocess.CalledProcessError as cp:
        log.error("neo4j-admin set-initial-password failed")
        return None

    try:
        # Determine whether to run neo4j in the foreground or in the background
        subcmd = 'start'
        if debug:
            subcmd = 'console'
        proc = subprocess.Popen([
            "ch-run",
            "--set-env=" + container_path + "/environment",
            "-b",
            gdb_config_path + ":/var/lib/neo4j/conf",
            "-b",
            gdb_data_path + ":/data",
            "-b",
            gdb_log_path + ":/logs",
            "-b",
            gdb_run_path + ":/var/lib/neo4j/run",
            "-b",
            gdb_certs_path + ":/var/lib/neo4j/certificates",
            container_path,
            "--",
            "neo4j",
            subcmd,
        ], stdout=stdout, stderr=stderr)
    except FileNotFoundError as e:
        # This is most likely caused by ch-run not existing
        log.error("neo4j failed to start. Charliecloud must be installed.")
        return None

    return proc

def StartWorkflowManager(bc, debug=False):
    """Start BEEWorkflowManager. Returns a Popen process object."""
    stdout = subprocess.PIPE
    stderr = subprocess.STDOUT
    if debug:
        stdout = sys.stdout
        stderr = sys.stdin

    return subprocess.Popen(["python", "beeflow/server/server.py"],
                          stdout=stdout, stderr=stderr)

def StartTaskManager(bc, debug=False):
    """Start BEETaskManager. Returns a Popen process object."""
    stdout = subprocess.PIPE
    stderr = subprocess.STDOUT
    if debug:
        stdout = sys.stdout
        stderr = sys.stdin

    return subprocess.Popen(["python", "beeflow/task_manager/task_manager.py"],
                            stdout=stdout, stderr=stderr)

def create_pid_file(proc, pid_file, bc):
    """Create a new PID file."""
    os.makedirs(os.path.expanduser('~/.beeflow'), exist_ok=True)
    with open(os.path.expanduser(f'~/.beeflow/{pid_file}'), 'w') as fp:
        fp.write(str(proc.pid))

def setup_logging(bc, debug=False):
    """
    Setup logging. Add default values to the config if not found. Return None on
    error and the log otherwise.
    """
    if debug:
        # Output everything to the console
        logging.basicConfig(level=logging.DEBUG)
    else:
        default = bc.userconfig['DEFAULT']
        bee_workdir = default.get('bee_workdir', '')
        logdir = default.get('logdir', os.path.join(bee_workdir, 'logs'))
        # Make the logdir if it doesn't exist already
        os.makedirs(logdir, exist_ok=True)
        logfile = default.get('logfile', 'bee.log')
        path = os.path.join(bee_workdir, logdir) if logdir else bee_workdir
        path = os.path.join(path, logfile)
        logging.basicConfig(filename=path)
    return logging.getLogger(__name__)

def parse_args(args=sys.argv[1:]):
    """Parse arguments."""
    parser = argparse.ArgumentParser(description=sys.modules[__name__].__doc__,
                                     formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument("-d", "--debug", action="store_true",
                        help="enable debugging output\nIf debug is specified all output will go to the console.\nOnly one BEE service may be launched by BEEStart if debug is requested.")
    parser.add_argument("--wfm", action="store_true", help="start the BEEWorkflowManager (implies --gdb)")
    parser.add_argument("--gdb", action="store_true", help="start the configured graph database")
    parser.add_argument("--tm", action="store_true", help="start the BEETaskManager")

    return parser.parse_args(args)

def main():
    args = parse_args()
    start_all = not any([args.wfm, args.tm, args.gdb])
    if args.debug and not (sum([args.wfm,args.tm,args.gdb]) == 1):
        print("DEBUG requested, exactly one service must be specified",
              file=sys.stderr)
        return 1
    bc = BeeConfig()
    # Setup logging based on args.debug
    log = setup_logging(bc, args.debug)
    if log is None:
        # Something went wrong
        return 1

    # Start all processes
    procs = []
    if args.wfm or start_all:
        proc = StartWorkflowManager(bc, args.debug)
        if proc is None:
            log.error('Workflow Manager failed to start. Exiting.')
            return 1
        create_pid_file(proc, 'wfm.pid', bc)
        procs.append(('Workflow Manager', proc))
        log.info('Started Workflow Manager')
    if args.tm or start_all:
        proc = StartTaskManager(bc, args.debug)
        if proc is None:
            log.error('Task Manager failed to start. Exiting.')
            return 1
        create_pid_file(proc, 'tm.pid', bc)
        procs.append(('Task Manager', proc))
        log.info('Started Task Manager')
    if args.gdb or args.wfm or start_all:
        proc = StartGDB(bc, args.debug)
        if proc is None:
            log.error('Graph Database failed to start. Exiting.')
            return 1
        create_pid_file(proc, 'gdb.pid', bc)
        procs.append(('Graph Database', proc))
        log.info('Started Graph Database')

    # Wait for everything to finish, if debug, otherwise just exit now
    if args.debug:
        while len(procs) > 0:
            name, proc = procs.pop()
            exit_code = proc.wait()
            if exit_code != 0:
                log.error('Error running %s', name)

    return 0

if __name__ == "__main__":
    sys.exit(main())
